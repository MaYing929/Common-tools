<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>析构赋值</title>
</head>
<body>

<script type="text/javascript" >
/*//    对象
/!*
    let  user = { name: 'guanguan', age: 2 };
    let  { name, age } = user;
    console.log('use前',user.name) //guanguan
    console.log('22',name)  //guanguan
    user.name='maying';
    console.log('use后',user.name)  //maying
    console.log('333',name)  //guanguan*!/
//  说明：析构 是对原对象的赋值而不是引用

//数组

const arr = [1, 2];
const [foo, bar] = arr;
console.log(foo);  // 1


    const name = 'maying';
    const age = 9;
    const user = {name,age}
    console.log('user',user)



/!*
app.model({
    reducers: {
        add() {}  // 等同于 add: function() {}
    },
    effects: {
        *addRemote() {}  // 等同于 addRemote: function*() {}
    },
});
*!/



    const todos = ['learn dva'];
    const uu = [...todos, 'Learn antd'];  // ['Learn dva', 'Learn antd']
    console.log('uu',uu)

//    获取数组的部分项目
       const  arr1 =['1','2','3','4',]
//     const [first,...rest] = arr1;
       const [first,,...rest] = arr1;
       console.log('rest',rest)



//    搜集函数参数为参数
/!*
    function directions (first,...rest){
       console.log('first,rest',first,rest)
    }

    directions('a', 'b', 'c')
*!/



//    代替apply


/!*
function foo1(x, y, z) {

    console.log('x',x)
}

const args = [1,2,3];

// 下面两句效果相同
foo1.apply(null, args);
foo1(...args);

*!/


//promises Promise 用于更优雅地处理异步请求。比如发起异步请求：

fetch('/api/todos')
        .then(res => res.json())
        .then(data => ({ data }))
        .catch(err => ({ err }));


//定义promises
const delay = (timeout) =>{
    return new Promise(resolve =>{
        setTimeout(resolve,timeout)
    })
}


delay(1000).then(_=>{
    console.log('executed')
})

//Generator

/!*dva 的 effects 是通过 generator 组织的。Generator 返回的是迭代器，通过 yield 关键字实现暂停功能。
这是一个典型的 dva effect，通过 yield 把异步逻辑通过同步的方式组织起来。 *!/

//
//app.model({
//    namespace: 'todos',
//    effects: {
//
//        *addRemote({ payload: todo }, { put, call }) {
//            yield call(addTodo, todo);
//            yield put({ type: 'add', payload: todo });
//        }
//    },
//});


/!*
function App(props) {

    function handleClick() {
        props.dispatch({ type: 'app/create' });
    }
    return <div onClick={handleClick}>${props.name}</div>
}
*!/



///!*
//class App extends React.Componnet {
//    handleClick() {
//        this.props.dispatch({ type: 'app/create' });
//    }
//    render() {
//        return <div onClick={this.handleClick.bind(this)}>${this.props.name}</div>
//    }
//}
//!*!/


/!*
const attrs = {
    href: 'http://example.org',
    target: '_blank',
};
<a {...attrs}>Hello</a>

*!/


//  ======


/!*
const attrs = {
    href: 'http://example.org',
    target: '_blank',
};
<a href={attrs.href} target={attrs.target}>Hello</a>

*!/*/


//数组的扩展

/*Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

下面是一个类似数组的对象，Array.from将它转为真正的数组。*/

/*
    let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        length: 3
    }

//    ES5 写法
    var arr1 = [].slice.call(arrayLike)
    console.log('ES5_arr1',arr1)
//ES6
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
console.log('ES5_arr2',arr2)
*/


// NodeList对象
//let ps = document.querySelectorAll('p');
//Array.from(ps).forEach(function (p) {
//    console.log(p);
//});


    /*
     // arguments对象
     function foo() {
     var args = Array.from(arguments);
     // ...
     }
    */

//如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。


Array.from([1, 2, 3])

//值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。


/*// arguments对象
function foo() {
    var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]*/

/*
* 所谓类似数组的对象，本质特征只有一点，即必须有length属性。
* 因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。
* */



Array.from({ length: 3 });
// [ undefined, undefined, undefined ]

//    函数的扩展
/*
    function log (x, y){
        y = y || 'World';
        console.log(x, y);
    }

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World


if (typeof y === 'undefined') {
    y = 'World';
}


function log2(x, y = 'World') {
    console.log(x, y);
}

log2('Hello') // Hello World
log2('Hello', 'China') // Hello China
log2('Hello', '') // Hello
    */


/*    function foo (x,y =5){
        console.log('x,y',x,y)
    }

    foo({})
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property 'x' of undefined

 */


/*
function fetch(url, { body = '', method = 'GET', headers = {} }) {
    console.log(method);
}

fetch('http://example.com', {}) // "GET"

//fetch('http://example.com')
//// 报错

*/


/*function fetch(url, { method = 'GET' } = {}) {
    console.log(method);
}

fetch('http://example.com')*/
// "GET"

//上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。
/*

// 写法一
function m1({x = 0, y = 0} = {}) {
    console.log([x, y]) ;
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
    console.log([x, y]) ;
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8})
m2({x: 3, y: 8})


m1({x: 3})  //[3,0]
m2({x: 3})  //[3,undefined]



m1({})  //[0,0]
m2({})  //[undefined,undefined]

m1({z: 3}) // [0,0]
m2({z: 3})  //[unfined,unfined]
*/

/*
上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象,
但是设置了对象解构赋值的默认值；
写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。
*/

/*
通常情况下，定义了默认值的参数，应该是函数的尾参数。
因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。*/
// 例一
/*function f(x, y = 5, z) {
    return [x, y, z];
}

f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]*/


/*如果传入undefined，将触发该参数等于默认值，null则没有这个效果。

function foo(x = 5, y = 6) {
    console.log(x, y);
}
//
//foo(undefined, null)
//// 5 null*/
//
//
////指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
//
//
////ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
///*function add(...values) {
//    let sum = 0;
//    console.log(Array.isArray(values))
//    for (var val of values) {
//        sum += val;
//    }
//
//    console.log(sum) ;
//}
//
//add(2, 5, 3) // 10
//
//
//function push(array, ...items) {
//
//    items.forEach(function(item) {
//        array.push(item);
//        console.log(array);
//    });
//}
//
//var a = [];
//push(a, 1, 2, 3)
//
//    */
//
///*
//console.log(...[1,2,3])
//
//console.log(1, ...[2, 3, 4], 5)
//
//
//
//function push(array, ...items) {
//    array.push(...items);
//}
//
//function add(x, y) {
//    return x + y;
//}
//
//var numbers = [4, 38];
//add(...numbers) // 42
//
//
//
//// ES5的写法
//function f(x, y, z) {
//  console.log('x,y,z',x,y,z)
//}
//var args = [0, 1, 2];
//
////ES5写法
//f.apply(null, args);
////Es6写法
//f(...args);
//
//
////扩展运算符还可以将字符串转为真正的数组。
//    console.log([...'sasa'])
//
//
//
//function length(str) {
//    return [...str].length;
//}
//
//
//
//var go = function*(){
//    yield 9;
//    yield 0;
//    yield 9;
//};
//
////console.log([...go()]) // [1, 2, 3]
//
//
//var f = v => v;
//
////     ====
//    var f = function(v){
//        return v
//    }
//
//
//
//
//    var f = () =>5
//
////     ===
//
//
//    var f = function(){
//        return 5
//    }
//
//    var sum = (num1,num2)=> num1+ num2;
////     ====
//
//
//    var sum = function (num1,num2){
//        return num1+ num2;
//    }
//
//
//
////由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。
//
//var getTempItem = id => ({ id: id, name: "Temp" });
//var getTempItem = id=({id:'sd'})
//
//
//
//const isEven = n => n % 2 == 0;
//const square = n => n * n;
//
//
//
//    const  isEven = n=> n % 2 == 0;
//
//    const squre = n=>n*n;
//
//
//    [1,2,3].map(function (){
//        return x*x;
//    })
//
//
////    箭头函数写法
//    [1,2,3].map(x=>x*x)
//
//
//    var result =  values.sort(function(a,b){
//        return a -b;
//    })
////箭头函数写法
// var result = values.sort((a,b)=> a-b)*/
//
///*   const numbers = (...nums) =>nums;
//   let a = numbers(1,2,3,4,5)
//   console.log('a',a)
//
//       console.log('全局函数的this',this)
//       const headAndTail =(head,...tail) =>{
//           console.log('箭头函数this',this)
//           return [head,tail]
//       }
//       console.log('headAndTail(1,2,3,4,5)',headAndTail(1,2,3,4,5))
//
//
//   console.log('全局_id:',this.id)
//    function  foo3(){*/
////           setTimeout(()=>{
////               console.log('foo3_id:',this.id)//箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。
////           },100)
//
///*        setTimeout(function(){
//            console.log('foo3_id:',this.id)   //this应该指向全局对象window，这时应该输出21。
//        },100)
//    }
//    var id = 21;
//    foo3.call({id:42})*/
////如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。
//
//
///*
//function Timer() {
//    this.s1 = 0;
//    this.s2 = 0;
//    // 箭头函数
//    setInterval(() => this.s1++, 1000);  //前者的this绑定定义时所在的作用域（即Timer函数），3100毫秒之后，timer.s1被更新了3次
//    // 普通函数
//    setInterval(function () {
//        this.s2++; //后者的this指向运行时所在的作用域（即全局对象）而timer.s2一次都没更新。
//    }, 1000);
//}
//
//var timer = new Timer();
//
//setTimeout(() => console.log('s1: ', timer.s1), 3100);
//setTimeout(() => console.log('s2: ', timer.s2), 3100);
//*/
//
//
////    对象扩展
//    var doo = 'bar';
//    var bax = {doo};
//    console.log('bax',bax)
////  ===
//   var bax2 = {doo:'bar'};
//  console.log('bax2',bax2)
//
//
//
//    function f(x,y){
//      return {x,y}
//    }
//
//
////    ===
//
//
//function f(x,y){
//    return {x:x,y:y}
//}
//
//var  i = {
//    method:function(){
//        return 'eee';
//    }
//}
//
//
////---
//
//var  i = {
//
//    method(){
//        return 'eee';
//    }
//}
//
//
//var birch = '2000/01/01';
//
//    var person ={
//        name:'账单',
//        birch,
//        hello(){ console.log('我的名字是' ,this,name)}
//    }
//
//    function getPoint (){
//        var x = 1;
//        var y = 10;
//     console.log({x,y})
//    }
//
//    getPoint()
//
//
//    var ms = {};
//
//    function getItem(key){
//        return key in ms ?ms[key]:null;
//    }
//    function setItem(key,value){
//        ms[key] = value;
//    }
//    function clear(){
//        ms = {}
//    }
//
//
//    moudle.exports = {getItem,setItem,clear};
//
//
//
//    moudle.export = {
//        getItem:getItem,
//        setItem:setItem,
//        clear:clear
//    }
//
//
//
//    var obj = {
//
//        cless(){}
//    }
//
//
////    ===
//
//var obj = {
//
//    'cless':function(){
//
//}}
//
////如果某个方法的值属于generation函数，前面需要加上*
////    var obj3 = {
////
////        *'cless':function(){
////
////        }
////
////}
//
//
//let propKey = 'foo';
//
//    let obj = {
//        [propKey]:true,
//        ['a']:'dsd',
//    }
//
//
//
//
//    var lastword = 'wqwq';
//
//
//    var a = {
//        'first_world':'cds',
//           [lastword]:'xsxsax',
//        //            ===
//            ['wqwq']:'xxsaxsa'
//        //如果某个方法的值属于generation函数，前面需要加上*
//                    *['wqwq']:'xxsaxsa'
//    }
//
//
//var person = {
//    sayName() {
//        console.log(this.name);
//    },
//    get firstName() {
//        return "Nicholas";
//    }
//};
//
//person.sayName.name   // "sayName"
//person.firstName.name // "get firstName"
//
////Object.is ==         ===全等于
//
//Object.is('foo', 'foo')
//// true
//Object.is({}, {})
//// false
//
//
////+0 === -0 //true
////NaN === NaN // false
////
////Object.is(+0, -0) // false
////Object.is(NaN, NaN) // true
//
//
//
//var target = { a: 1 };
//
//var source1 = { b: 2 };
//var source2 = { c: 3 };
//
//Object.assign(target, source1, source2);
//target // {a:1, b:2, c:3}
//
//
//
//var target = { a: 1, b: 1 };
//
//var source1 = { b: 2, c: 2 };
//var source2 = { c: 3 };
//
//Object.assign(target, source1, source2);
//target // {a:1, b:2, c:3}
//
//// 如果只有一个参数，会直接返回该参数
//var obj = {a: 1};
//Object.assign(obj) === obj // true
//
//
////如果该参数不是对象，则会先转成对象，然后返回。
////如果该参数不是对象，则会先转为对象然后返回
//typeof Object.assign(2) // "object"
//
//

//Symbol

//
//let s = Symbol();
//
//typeof s
//// "symbol"


/*

var s = new Set();

[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));

for (let i of s) {
    console.log(i);
}

s.add(1).add(2).add(3)


var set = new Set([1,2,3,3,3,5,6]);

    console.log([...set])

var set2 = new Set([1,2,3,3,3,5,6]);

console.log(set2.size)


//        // 去除数组的重复成员
//        [...new Set(array)]

//两个对象总是不相等的
//let set = new Set();
//
//set.add({});
//set.size // 1
//
//set.add({});
//set.size // 2
//
//
//
//var map = new Map([
//    ['name', '张三'],
//    ['title', 'Author']
//]);
//
//map.size // 2
//map.has('name') // true
//map.get('name') // "张三"
//map.has('title') // true
//map.get('title') // "Author"
//
//*/
//
//
///*var obj = new Proxy({}, {
//    get: function (target, key, receiver) {
//        console.log(`getting ${key}!`);
//        return Reflect.get(target, key, receiver);
//    },
//    set: function (target, key, value, receiver) {
//        console.log(`setting ${key}!`);
//        return Reflect.set(target, key, value, receiver);
//    }
//});*/
//
//
//
//function* helloWorldGenerator() {
//    yield 'hello';
//    yield 'world';
//    return 'ending';
//}
//
//var hw = helloWorldGenerator();
//    console.log('hw',hw.next())
//console.log('hw',hw.next())
//console.log('hw',hw.next())
//console.log('hw',hw.next())
//
//
//function* f() {
//    console.log('执行了！')
//}
//
//var generator = f();
//
//console.log(generator.next())
///*setTimeout(function () {
//    generator.next()
//}, 2000);*/
//
////Promise
////    创建实例
//    var promise = new Promise(function(resolve,reject){
//           console.log('dewdew')
//        if(异步调用成功){
//            resolve(value);
//        }else{
//            reject(error)
//        }
//    })
//
//
////Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。
//promise.then(function(value){
//    //sucess
//},function(error){
//       //fail
//        }
//)
//
//
//
//function timeout(ms) {
//    return new Promise((resolve, reject) => {
//        setTimeout(resolve, ms, 'done');
//    });
//}
//
//timeout(100).then((value) => {
//    console.log(value);
//});
//
////异步操作
////回调函数的操作
//
//
//fs.readFile(fileA, function (err, data) {
//    fs.readFile(fileB, function (err, data) {
//        // ...
//    });
//});
//
////promise它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用
//var readFile = require('fs-readfile-promise');
//
//readFile(fileA)
//        .then(function(data){
//            console.log(data.toString());
//        })
//        .then(function(){
//            return readFile(fileB);
//        })
//        .then(function(data){
//            console.log(data.toString());
//        })
//        .catch(function(err) {
//            console.log(err);
//        });
////可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。
//
////    Generator函数
////协程 意思是多个线程互相协作，完成异步任务。
//
///*协程有点像函数，又有点像线程。它的运行流程大致如下。
//
//第一步，协程A开始执行。
//第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
//第三步，（一段时间后）协程B交还执行权。
//第四步，协程A恢复执行。*/
//
//
//function *asyncJob(){
//    //其他大妈
//    var  f = yield  readFile(fileA);
//    //。。。其他代码
//}
////    执行到yield 语句的语句的时候执行权交给其他的携程 yield命令式是异步两个阶段的分界线
//Decorator
//Module
//编程风格
//读懂规格
//二进制数组
//SIMD
//参考链接
//其他
//
//源码
//修订历史
//反馈意见
//异步操作和Async函数
//
//基本概念
//Generator函数
//Thunk函数
//co模块
//async函数
//异步遍历器
//异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。
//
//ES6诞生以前，异步编程的方法，大概有下面四种。
//
//回调函数
//事件监听
//发布/订阅
//Promise 对象
//ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。
//
//基本概念
//异步
//所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。
//
//比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。
//
//相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。
//
//回调函数
//JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。
//
//读取文件进行处理，是这样写的。
//
//fs.readFile('/etc/passwd', function (err, data) {
//    if (err) throw err;
//    console.log(data);
//});
//上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。
//
//一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。
//
//Promise
//回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。
//
//fs.readFile(fileA, function (err, data) {
//    fs.readFile(fileB, function (err, data) {
//        // ...
//    });
//});
//不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数地狱"（callback hell）。
//
//Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。
//
//var readFile = require('fs-readfile-promise');
//
//readFile(fileA)
//        .then(function(data){
//            console.log(data.toString());
//        })
//        .then(function(){
//            return readFile(fileB);
//        })
//        .then(function(data){
//            console.log(data.toString());
//        })
//        .catch(function(err) {
//            console.log(err);
//        });
/*上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。

可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。

Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。

那么，有没有更好的写法呢？*/

//Generator函数
//协程
//传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。

//协程有点像函数，又有点像线程。它的运行流程大致如下。

//第一步，协程A开始执行。
//第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
//第三步，（一段时间后）协程B交还执行权。
//第四步，协程A恢复执行。
//上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。

//举例来说，读取文件的协程写法如下。
//
//function *asyncJob() {
//    // ...其他代码
//    var f = yield readFile(fileA);
//    // ...其他代码
//}
//上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。

//协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。


function* gen(x){
    var y = yield x + 2;
    return y;
}


var g = gen(1);
g.next();
g.next();


function* gen(x){
    try {
        var y = yield x + 2;
    } catch (e){
        console.log(e);
    }
    return y;
}

var g = gen(1);
g.next();
g.throw('出错了');



var fetch = require('node-fetch');

function* gen(){
    var url = 'https://api.github.com/users/github';
    var result = yield fetch(url);
    console.log(result.bio);
}

var g = gen();
var result = g.next();

result.value.then(function(data){
    return data.json();
}).then(function(data){
    g.next(data);
});




//    class 基本语法
//构造函数的写法
    function Point(x,y){
        this.x = x;
        this.y  = y;
    }
Point.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ')';
};
var p = new Point(1, 2);
    console.lgo('p',p)

//    ====

//，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。
//上面代码表明，类的数据类型就是函数，类本身就指向构造函数。

//ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。


class Point{

        constructor(x,y){
            this.x = x;
            this.y =y;
        }
        toString(){
            return '(' + this.x + ', ' + this.y + ')';
        }

    }


class Bar {
    doStuff() {
        console.log('stuff');
    }
}

var b = new Bar();
b.doStuff() // "stuff"



class Point {

    constructor(){
        // ...
    }

    toString(){
        // ...
    }

    toValue(){
        // ...
    }
}

// 等同于

Point.prototype = {
    toString(){},
    toValue(){}
};

//ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
//当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。
import { stat, exists, readFile } from 'fs';
</script>
</body>
</html>